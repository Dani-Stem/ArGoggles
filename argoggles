import cv2
import mediapipe as mp
import threading
import base64
import requests
import json
import random
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.image import Image
from kivy.graphics.texture import Texture
from kivy.clock import Clock
from kivy.uix.button import Button
from kivy.uix.label import Label

openai.api_key = 'your-api-key'
BUBBLE_POPPING_DISTANCE_THRESHOLD = 50

class ScoreKeeper:
    def __init__(self):
        self.score = 0

    def increment_score(self):
        self.score += 1

    def get_score(self):
        return self.score

class EncouragementAgent:
    def get_encouragement(self):
        phrases = [
            "Great job!", "Keep going!", "You're doing fantastic!",
            "Wow, nice pop!", "Keep the streak alive!"
        ]
        return random.choice(phrases)

class NewPlayerAdvisor:
    def get_advice(self):
        advice = [
            "Try to pop the bubbles with your hands!", "The red bubbles are worth more points!",
            "Be quick, the bubbles will disappear!", "Use both hands to pop more bubbles!",
            "Watch out for the special golden bubble!"
        ]
        return random.choice(advice)

class BubbleGame:
    def __init__(self, score_keeper):
        self.bubbles = []
        self.score_keeper = score_keeper

    def create_bubble(self, color, position):
        self.bubbles.append({'color': color, 'position': position, 'popped': False})

    def pop_bubble(self, hand_positions):
        for hand_position in hand_positions:
            for bubble in self.bubbles:
                if not bubble['popped'] and self.is_hand_near_bubble(hand_position, bubble['position']):
                    bubble['popped'] = True
                    self.score_keeper.increment_score()

    def is_hand_near_bubble(self, hand_position, bubble_position):
        distance = ((hand_position[0] - bubble_position[0]) ** 2 + (hand_position[1] - bubble_position[1]) ** 2) ** 0.5
        return distance < BUBBLE_POPPING_DISTANCE_THRESHOLD

class HandDetector:
    def __init__(self):
        self.cap = cv2.VideoCapture(0)
        self.mp_hands = mp.solutions.hands
        self.hands = self.mp_hands.Hands()
        self.mp_draw = mp.solutions.drawing_utils
        self.lock = threading.Lock()
        self.frame = None
        threading.Thread(target=self.run, daemon=True).start()

    def run(self):
        while True:
            success, img = self.cap.read()
            if success:
                self.lock.acquire()
                self.frame = img
                self.lock.release()

    def get_frame(self):
        self.lock.acquire()
        frame = self.frame
        self.lock.release()
        return frame

    def find_hands(self, img):
        imgRGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        self.results = self.hands.process(imgRGB)
        if self.results.multi_hand_landmarks:
            for handLms in self.results.multi_hand_landmarks:
                self.mp_draw.draw_landmarks(img, handLms, self.mp_hands.HAND_CONNECTIONS)
        return img

    def get_hand_positions(self):
        positions = []
        if self.results.multi_hand_landmarks:
            for handLms in self.results.multi_hand_landmarks:
                for id, lm in enumerate(handLms.landmark):
                    h, w, c = self.frame.shape
                    cx, cy = int(lm.x * w), int(lm.y * h)
                    positions.append((cx, cy))
        return positions

    def close(self):
        self.cap.release()

class KivyCamera(Image):
    def __init__(self, capture, fps, **kwargs):
        super(KivyCamera, self).__init__(**kwargs)
        self.capture = capture
        Clock.schedule_interval(self.update, 1.0 / fps)

    def update(self, dt):
        frame = self.capture.get_frame()
        if frame is not None:
            frame = self.capture.find_hands(frame)
            buf = cv2.flip(frame, 0).tostring()
            texture = Texture.create(size=(frame.shape[1], frame.shape[0]), colorfmt='bgr')
            texture.blit_buffer(buf, colorfmt='bgr', bufferfmt='ubyte')
            self.texture = texture

class GameApp(App):
    def build(self):
        self.score_keeper = ScoreKeeper()
        self.encouragement_agent = EncouragementAgent()
        self.new_player_advisor = NewPlayerAdvisor()
        self.game = BubbleGame(self.score_keeper)
        self.detector = HandDetector()
        self.img1 = KivyCamera(capture=self.detector, fps=30)
        layout = BoxLayout(orientation='vertical')
        layout.add_widget(self.img1)
        self.score_label = Label(text=f"Score: {self.score_keeper.get_score()}")
        layout.add_widget(self.score_label)
        self.encouragement_label = Label(text="")
        layout.add_widget(self.encouragement_label)
        self.advice_label = Label(text="")
        layout.add_widget(self.advice_label)
        self.send_button = Button(text='Pop Bubble')
        self.send_button.bind(on_press=self.on_enter)
        layout.add_widget(self.send_button)
        return layout

    def on_enter(self, instance):
        frame = self.detector.get_frame()
        hand_positions = self.detector.get_hand_positions()
        self.game.pop_bubble(hand_positions)
        self.score_label.text = f"Score: {self.score_keeper.get_score()}"
        self.encouragement_label.text = self.encouragement_agent.get_encouragement()
        self.advice_label.text = self.new_player_advisor.get_advice()
        encoded_image = self.encode_image_to_base64(frame)
        self.send_images_to_gpt4([encoded_image])

    def encode_image_to_base64(self, frame):
        _, buffer = cv2.imencode('.jpg', frame)
        return base64.b64encode(buffer).decode('utf-8')

    def send_images_to_gpt4(self, base64_images):
        headers = {
            'Authorization': f'Bearer {openai.api_key}',
            'Content-Type': 'application/json'
        }
        messages = [
            {
                'role': 'user',
                'content': [
                    {'type': 'text', 'text': 'Did the player pop a bubble in these images?'},
                    {'type': 'text', 'text': 'Can you give some words of encouragement for the player based on these images?'},
                    {'type': 'text', 'text': 'What advice would you give to a new player based on these images?'}
                ]
            }
        ]
        for base64_image in base64_images:
            messages[0]['content'].append(
                {'type': 'image_url', 'image_url': f'data:image/jpeg;base64,{base64_image}'}
            )
        data = {
            'model': 'gpt-4-vision-preview',
            'messages': messages,
            'max_tokens': 300
        }
        response = requests.post('https://api.openai.com/v1/chat/completions', headers=headers, json=data)
        self.interpret_response(response.json())

    def interpret_response(self, response):
        text_response = response['choices'][0]['message']['content']
        print(text_response)

    def on_stop(self):
        self.detector.close()

    def update(self, dt):
        frame = self.detector.get_frame()
        if frame is not None:
            hand_positions = self.detector.get_hand_positions()
            self.game.pop_bubble(hand_positions)
            self.score_label.text = f"Score: {self.score_keeper.get_score()}"

if __name__ == '__main__':
    app = GameApp()
    Clock.schedule_interval(app.update, 1.0 / 30.0)
    app.run()
